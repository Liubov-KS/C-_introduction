/*
Заполните спирально массив 4 на 4.
Например, на выходе получается вот такой массив:

01 02 03 04
12 13 14 05
11 16 15 06
10 09 08 07
*/

/*
Задача для меня оказалась непростой. Комментарии здесь и далее предназначены скорее для меня.
Само заполнение массива видиться тривиальной задачей. Можно генерить значения на ходу или брать из заранее подготовленного массива.
Сложность представляет описание алгоритма движения по массиву, а точнее, описание условий поворота по спирали на C# 
(хотя это не единственный способ обхода) с учетом ограничивающих
условий и желания написать оптимальный (ха-ха) и читаемый код.

На естественном языке, алгоритм обхода можно описать так:
1. Начинаем в элементе [0,0];

2. Движемся по строке слева на право до конца строки или пока не встретим ненулевой элемент;

3. При соблюдении одного из условий выше, поворачиваем вниз и движемся по столбцу пока не дойдем до конца или пока не встретим ненулевой элемент;

4. Поворачиваем и движемся по строке справа на лево до начала строки или пока не встретим ненулевой элемент.

5. При соблюдении одного из условий выше поворачиваем направо и движемся по столбу снизу вверх. 
   или пока не встретим ненулевой элемент. 
   (цикл замкнулся).
*/

int[,] matrix = new int[4,4];

// реализация работает, но, к сожалению, только к матрице 4х4, на нее завязаны условия. 
// Другое дело, что значение тиков в условиях зависят от размера матрицы функционально
// Надо подумать, как адаптировать алгоритм для матрицы любого размера.

void MatrixSpiralFiller(int[,] matrix, int x, int y, int tic)
{
    if (tic == 17) return;
    matrix[x, y] = tic;
    tic++;
    if ((tic >= 1 && tic <= 4) || ((tic >= 13 && tic <= 14))) MatrixSpiralFiller(matrix, x, y+1, tic); // идем по строке слева направо
    if ((tic >= 5 && tic <= 7) || tic == 15) MatrixSpiralFiller(matrix, x+1, y, tic);                  // идем по столбцу сверху вниз
    if ((tic >= 8 && tic <= 10)|| tic == 16) MatrixSpiralFiller(matrix, x, y-1, tic);                  // идем по строке справа налево
    if (tic >= 11 && tic <= 12) MatrixSpiralFiller(matrix, x-1, y, tic);                               // идем по столбцу снизу вверх    
}


// вывод модифицирован еще одним хаком, что бы добавить лидирующий ноль. есть специальные методы для этого, но уже стало лень.
// "Работает же!"
void PrinterMatrix(int[,] matrix)
{
   for (int i = 0; i < matrix.GetLength(0); i++)
    {
        for (int j = 0; j < matrix.GetLength(1); j++)
        {
            if (j == 0) Console.Write("[");
            if (matrix[i,j] < 10) Console.Write("0");
            if (j < matrix.GetLength(1) - 1) Console.Write($"{matrix[i,j]}, ");
            else Console.Write($"{matrix[i,j]}]");    
        }
        Console.WriteLine();
    }
}

MatrixSpiralFiller(matrix, 0, 0, 1);
PrinterMatrix(matrix);


    if (tic == matrix.GetLength(0)*matrix.GetLength(1)) return; // tic стартует с 0.
    matrix[x, y] = tic;
    tic++;
    if ((tic >= 0 && tic <= matrix.GetLength(1)-1) || ((tic >= 13 && tic <= 14))) MatrixSpiralFiller(matrix, x, y+1, tic); // идем по строке слева направо
    if ((tic >= 5 && tic <= 7) || tic == 15) MatrixSpiralFiller(matrix, x+1, y, tic);                  // идем по столбцу сверху вниз
    if ((tic >= 8 && tic <= 10)|| tic == 16) MatrixSpiralFiller(matrix, x, y-1, tic);                  // идем по строке справа налево
    if (tic >= 11 && tic <= 12) MatrixSpiralFiller(matrix, x-1, y, tic);                               // идем по столбцу снизу вверх    